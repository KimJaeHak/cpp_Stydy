# CPP Fundament
## 열형 강의 C++
\- **키워드 mutable**</br>
>**Const 함수 내에서의 값의 변경을 예외적으로 허용한다.**</br>

가급적 사용하지 말아야 할 키워드 이다.

###- 상속(Inheritance)
---

```cpp
class UnivStudent : public Person
{
    ...
}

class UnivStudent : protected Person
{
    ...
}

```

\- Person 옆의 public, protected 키워드의 의미는?  
 의미)  부모 클래스를 상속시에 키워드 보다 범위가 넓은 맴버는 선언된 키워드 범위로 상속한다는 의미 이다.   
다시 말해서 protected의 키워드를 사용하면 **Person의 맴버중 public맴버를 모두 protected로 바꾸어서 상속 하겠다는** 의미 이다. 
>**특별한 경우가 아니면 C++에서는 public상속을 주로 사용한다.**

\- UnivStudent 생성자는 Person의 멤버까지 초기화 해야하는 의무가 있다.  

```cpp
UnivStudent(char* name, int age, char* mymajor)
		:Person(myage, myname)
{
...
}
```

\- 위 와 같이 Base(부모)클래스의 생성자를 바로 호출해서 맴버를 초기화 해준다.  
\- Derived(자식) 클래스를 생성 할때 부모 클래스의 생성자를 명시적으로 호출 하지 않으면, 부모 클래스의 Void 생성자가 호출 된다.  
>**클래스의 맴버는 클래스의 생성자를 통해서 초기화 해야 한다.** 

###- 다형성
---
#### 객체 포인터의 참조관계
부모 클래스형 포인터는 자식클래스의 객체를 가리킬 수 있다.  
Person(부모 클래스) , Student(자식클래스)

```cpp
Person *ptr = new Student();
```

overriding된 자식 클래스의 함수는 부모 클래스의 함수를 (hide)가린다.  
명시적으로 부모 클래스의 함수를 호출 할 수 있다.
```cpp
BBB bbb = new BBB();
bbb.AAA::ParentFunction();
```

>명시적으로 부모클래스의 함수를 호출 할 수 있으나 거의 사용할 일이 없다.

#### 가상함수
```cpp
class First
{
public:
    virtual void MyFunc(){cout<<"hello World"<<endl;}
};
```

가상함수는 virtual이라는 키워드로 선언된다. **이 함수를 오버라이딩 하는 함수도 가상함수가 된다.**  
자식 클래스에서 오버라이딩 할 때에도 함수에 Virtual 키워드를 붙여 주는 것이 좋다.(명시적으로 가상함수를 표시하기 위해서)  

#### 순수 가상함수 와 추상 클래스
객체 생성이 목적이 아닌 클래스가 존재 하게 된다. 이 클래스의 객체를 생성하지 못하도록 강제하는 방법.  
> **순수 가상함수를 선언하자.**

```cpp
class Employee
{
private:
    char name[100];

public:
    virtual int GetPay() const = 0; //순수 가상함수
}
```
순수 가상함수는 몸체가 없으며, virtual 키워드와 = 0 을 사용해서 선언한다.  
이 함수를 선언해서 두가지 이점이 생긴다.  
1. 잘못해서 객체를 생성하는 실수를 막을 수 있다.(객체를 생성할 수 없게 강제하기 때문에)  
2. 실제로 Employee에서 실행되는 함수가 아니라는 것을 명시적으로 나타낸다.  

> 순수 가상함수가 하나 이상 존재하는 클래스는 **추상클래스**가 된다.  

#### 가상 소멸자
```cpp
class First
{
public:
    ~First(){...}
}

class Second:public First
{
public:
    ~Second(){...}
}

int main()
{
    First* first = new Second();
    delete first
    return 0;
}
```

위의 코드를 실행 하면 소멸자가 2번 호출되어야 memory leak 없이 정상적으로 종료 될 것이다.  
하지만 실제로 실행해 보면 소멸자는 한번만 호출이 된다.
>그렇다면 소멸자가 정상적으로 두번 호출 되려면 어떻게 해야할까?

```cpp
class First
{
public:
    virtual ~First(){...}
}

class Second:public First
{
public:
    virtual ~Second(){...}
}

int main()
{
    First* first = new Second();
    delete first
    return 0;
}
```

>**바로 소멸자에 virtual키워드를 붙여주는 것이다.**  

이렇게 하면 정상적으로 2번 소멸자가 호출된다.

#### 다중 상속
C++는 다중 상속을 지원한다(사용하지 않는것을 추천)  
```cpp
class BaseOne
{
public:
    void SimpleFunc(){...}
}

class BaseTwo
{
public:
    void SimpleFunc(){...}
}

class MultiDerived : public BaseOne, protected BaseTwo
{
public:
    void ComplexFunction()
    {
        //명시적으로 호출해줘야 한다.
        BaseOne::SimpleFunc();
        BaseOne::SimpleFunc();       
    }
}

```

#### 가상 상속
```cpp
class Base
{
public:
    Base(){...}
    void SimpleFunc(){...}
}

class MiddleDerivedOne : virtual public Base
{
public:
    MiddleDerivedOne() : Base()
    {
        ...
    }
}

class MiddleDerivedTwo : virtual public Base
{
public:
    MiddleDerivedTwo() : Base()
    {
        ...
    }
}

class LastDerived : public MiddleDerivedOne, public  MiddleDerivedTwo
{
public:
    LastDerived() : MiddleDerivedOne() , MiddleDerivedTwo()
    {
        ...
    }
    
    void ComplexFunc()
    {
        MiddleFuncOne();
        MiddleFuncTwo();
        //명시적으로 호출해줄 필요가 없다 Virtual로 Base를 상속 받았기 때문에 한번 만 상속을 했기 때문이다.
        //다중 상속을 막아 준다.
        //만약 virtual키워드로 상속 하지 않았다면, 아래와 같이 호출 해야 할것 이다.
        //MiddleDerivedOne::SimpleFunc();
        //MiddleDerivedTwo::SimpleFunc();
        SimpleFunc();
    }
}

```

> **또한 Virtual로 상속을 받았기 때문에 되면 Base의 생성자도 한번만 호출 된다.**

###- 연산자 오버로딩
----